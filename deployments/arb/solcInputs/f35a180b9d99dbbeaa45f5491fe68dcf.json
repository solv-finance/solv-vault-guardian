{
  "language": "Solidity",
  "sources": {
    "lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "lib/safe-contracts-1.3.0/contracts/base/GuardManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\n\ninterface Guard {\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external;\n\n    function checkAfterExecution(bytes32 txHash, bool success) external;\n}\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract GuardManager is SelfAuthorized {\n    event ChangedGuard(address guard);\n    // keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Set a guard that checks transactions before execution\n    /// @param guard The address of the guard to be used or the 0 address to disable the guard\n    function setGuard(address guard) external authorized {\n        bytes32 slot = GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, guard)\n        }\n        emit ChangedGuard(guard);\n    }\n\n    function getGuard() internal view returns (address guard) {\n        bytes32 slot = GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            guard := sload(slot)\n        }\n    }\n}\n"
    },
    "lib/safe-contracts-1.3.0/contracts/common/Enum.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}\n"
    },
    "lib/safe-contracts-1.3.0/contracts/common/SelfAuthorized.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SelfAuthorized - authorizes current contract to perform actions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SelfAuthorized {\n    function requireSelfCall() private view {\n        require(msg.sender == address(this), \"GS031\");\n    }\n\n    modifier authorized() {\n        // This is a function call as it minimized the bytecode size\n        requireSelfCall();\n        _;\n    }\n}\n"
    },
    "src/authorizations/agni/AgniAuthorization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {FunctionAuthorization} from \"../../common/FunctionAuthorization.sol\";\nimport {AgniAuthorizationACL} from \"./AgniAuthorizationACL.sol\";\nimport {Governable} from \"../../utils/Governable.sol\";\n\ncontract AgniAuthorization is FunctionAuthorization {\n\n    string public constant NAME = \"SolvVaultGuardian_AgniAuthorization\";\n    uint256 public constant VERSION = 1;\n\n    /**\n     * On Mantle\n     * Agni SwapRouter: 0x319B69888b0d11cEC22caA5034e25FfFBDc88421\n     */\n    constructor(\n        address safeMultiSendContract_,\n        address caller_,\n        address safeAccount_,\n        address agniSwapRouter_,\n        address[] memory swapTokenWhitelist_\n    ) \n        FunctionAuthorization(safeMultiSendContract_, caller_, Governable(caller_).governor()) \n    {\n        string[] memory agniSwapRouterFuncs = new string[](2);\n        agniSwapRouterFuncs[0] = \"exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))\";\n        agniSwapRouterFuncs[1] = \"exactInput((bytes,address,uint256,uint256,uint256))\";\n        _addContractFuncs(agniSwapRouter_, agniSwapRouterFuncs);\n\n        address acl = address(new AgniAuthorizationACL(address(this), safeAccount_, agniSwapRouter_, swapTokenWhitelist_));\n        _setContractACL(agniSwapRouter_, acl);\n    }\n}\n"
    },
    "src/authorizations/agni/AgniAuthorizationACL.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport {BaseACL} from \"../../common/BaseACL.sol\";\nimport {Path} from \"../../libraries/Path.sol\";\n\nstruct ExactInputSingleParams {\n    address tokenIn;\n    address tokenOut;\n    uint24 fee;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n    uint160 sqrtPriceLimitX96;\n}\n\nstruct ExactInputParams {\n    bytes path;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n}\n\ncontract AgniAuthorizationACL is BaseACL {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Path for bytes;\n\n    string public constant NAME = \"SolvVaultGuardian_AgniAuthorizationACL\";\n    uint256 public constant VERSION = 1;\n\n    address public agniSwapRouter;\n\n    EnumerableSet.AddressSet internal _tokenWhitelist;\n\n    event AddTokenWhitelist(address indexed token);\n\n    constructor(\n        address caller_,\n        address safeAccount_,\n        address agniSwapRouter_,\n        address[] memory tokenWhitelist_\n    ) BaseACL(caller_) {\n        safeAccount = safeAccount_;\n        agniSwapRouter = agniSwapRouter_;\n        for (uint256 i = 0; i < tokenWhitelist_.length; i++) {\n            _addTokenWhitelist(tokenWhitelist_[i]);\n        }\n    }\n\n    function _addTokenWhitelist(address token) internal {\n        require(token != address(0), \"AgniACL: token cannot be the zero address\");\n        if (_tokenWhitelist.add(token)) {\n            emit AddTokenWhitelist(token);\n        }\n    }\n\n    function checkToken(address token) public view virtual returns (bool) {\n        return _tokenWhitelist.contains(token);\n    }\n\n    function exactInputSingle(ExactInputSingleParams calldata params) external view virtual {\n        _checkValueZero();\n        require(params.recipient == safeAccount, \"AgniACL: recipient not allowed\");\n        require(checkToken(params.tokenIn), \"AgniACL: tokenIn not allowed\");\n        require(checkToken(params.tokenOut), \"AgniACL: tokenOut not allowed\");\n    }\n\n    function exactInput(ExactInputParams calldata params) external view virtual {\n        _checkValueZero();\n        require(params.recipient == safeAccount, \"AgniACL: recipient not allowed\");\n\n        bytes memory path = params.path;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n            (address tokenIn, address tokenOut,) = path.decodeFirstPool();\n            require(checkToken(tokenIn), \"AgniACL: tokenIn not allowed\");\n            require(checkToken(tokenOut), \"AgniACL: tokenOut not allowed\");\n            if (hasMultiplePools) {\n                path = path.skipToken();\n            } else {\n                break;\n            }\n        }\n    }\n\n}\n"
    },
    "src/authorizations/CoboArgusAdminAuthorization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {FunctionAuthorization} from \"../common/FunctionAuthorization.sol\";\nimport {Governable} from \"../utils/Governable.sol\";\n\ncontract CoboArgusAdminAuthorization is FunctionAuthorization {\n    string public constant NAME = \"SolvVaultGuardian_CoboArgusAdminAuthorization\";\n    int256 public constant VERSION = 1;\n\n    /**\n     * On Arbitrum\n     * argusAccountHelper : 0x58D3a5586A8083A207A01F21B971157921744807\n     * argusFlatRoleManager : 0x80346Efdc8957843A472e5fdaD12Ea4fD340A845\n     * argusFarmingBaseAcl : 0xFd11981Da6af3142555e3c8B60d868C7D7eE1963\n     */\n    constructor(\n        address safeMultiSendContract_,\n        address caller_,\n        address argusAccountHelper_,\n        address argusFlatRoleManager_,\n        address argusFarmingBaseAcl_\n    ) FunctionAuthorization(safeMultiSendContract_, caller_, Governable(caller_).governor()) {\n        string[] memory argusAccountHelperFuncs = new string[](6);\n        argusAccountHelperFuncs[0] = \"initArgus(address,bytes32)\";\n        argusAccountHelperFuncs[1] = \"createAuthorizer(address,address,bytes32,bytes32)\";\n        argusAccountHelperFuncs[2] = \"addAuthorizer(address,address,bool,bytes32[])\";\n        argusAccountHelperFuncs[3] = \"addFuncAuthorizer(address,address,bool,bytes32[],address[],string[][],bytes32)\";\n        argusAccountHelperFuncs[4] = \"grantRoles(address,bytes32[],address[])\";\n        argusAccountHelperFuncs[5] = \"revokeRoles(address,bytes32[],address[])\";\n        _addContractFuncs(argusAccountHelper_, argusAccountHelperFuncs);\n\n        string[] memory argusFlatRoleManagerFuncs = new string[](1);\n        argusFlatRoleManagerFuncs[0] = \"addRoles(bytes32[])\";\n        _addContractFuncs(argusFlatRoleManager_, argusFlatRoleManagerFuncs);\n\n        string[] memory argusFarmingBaseAclFuncs = new string[](1);\n        argusFarmingBaseAclFuncs[0] = \"addPoolAddresses(address[])\";\n        _addContractFuncs(argusFarmingBaseAcl_, argusFarmingBaseAclFuncs);\n    }\n}\n"
    },
    "src/authorizations/ERC20ApproveAuthorization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport {Type} from \"../common/Type.sol\";\nimport {FunctionAuthorization} from \"../common/FunctionAuthorization.sol\";\nimport {Governable} from \"../utils/Governable.sol\";\n\ncontract ERC20ApproveAuthorization is FunctionAuthorization {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    string public constant NAME = \"SolvVaultGuardian_ERC20ApproveAuthorization\";\n    int256 public constant VERSION = 1;\n\n    string internal constant ERC20_APPROVE_FUNC = \"approve(address,uint256)\";\n    string internal constant ERC20_INCREASE_ALLOWANCE_FUNC = \"increaseAllowance(address,uint256)\";\n    string internal constant ERC20_DECREASE_ALLOWANCE_FUNC = \"decreaseAllowance(address,uint256)\";\n    \n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    event TokenAdded(address indexed token);\n    event TokenRemoved(address indexed token);\n    event TokenSpenderAdded(address indexed token, address indexed spender);\n\n    address public safeAccount;\n    string[] internal _approveFuncs;\n\n    EnumerableSet.AddressSet internal _tokenSet;\n    mapping(address => EnumerableSet.AddressSet) internal _allowedTokenSpenders;\n\n    struct TokenSpenders {\n        address token;\n        address[] spenders;\n    }\n\n    constructor(address safeMultiSendContract_, address caller_, TokenSpenders[] memory tokenSpenders_)\n        FunctionAuthorization(safeMultiSendContract_, caller_, Governable(caller_).governor())\n    {\n        _approveFuncs = new string[](3);\n        _approveFuncs[0] = ERC20_APPROVE_FUNC;\n        _approveFuncs[1] = ERC20_INCREASE_ALLOWANCE_FUNC;\n        _approveFuncs[2] = ERC20_DECREASE_ALLOWANCE_FUNC;\n        _addTokenSpenders(tokenSpenders_);\n    }\n\n    function addTokenSpenders(TokenSpenders[] calldata tokenSpendersList_) external virtual onlyGovernor {\n        _addTokenSpenders(tokenSpendersList_);\n    }\n\n    function removeTokenSpenders(TokenSpenders[] calldata tokenSpendersList_) external virtual onlyGovernor {\n        _removeTokenSpenders(tokenSpendersList_);\n    }\n\n    function _addTokenSpenders(TokenSpenders[] memory _tokenSpendersList) internal virtual {\n        for (uint256 i = 0; i < _tokenSpendersList.length; i++) {\n            _addTokenSpenders(_tokenSpendersList[i]);\n        }\n    }\n\n    function _removeTokenSpenders(TokenSpenders[] memory _tokenSpendersList) internal virtual {\n        for (uint256 i = 0; i < _tokenSpendersList.length; i++) {\n            _removeTokenSpenders(_tokenSpendersList[i]);\n        }\n    }\n\n    function _addTokenSpenders(TokenSpenders memory _tokenSpenders) internal virtual {\n        address token = _tokenSpenders.token;\n        address[] memory spenders = _tokenSpenders.spenders;\n        if (_tokenSet.add(token)) {\n            _addContractFuncs(token, _approveFuncs);\n            emit TokenAdded(token);\n        }\n        for (uint256 i = 0; i < spenders.length; i++) {\n            if (_allowedTokenSpenders[token].add(spenders[i])) {\n                emit TokenSpenderAdded(token, spenders[i]);\n            }\n        }\n    }\n\n    function _removeTokenSpenders(TokenSpenders memory _tokenSpenders) internal virtual {\n        address token = _tokenSpenders.token;\n        address[] memory spenders = _tokenSpenders.spenders;\n        for (uint256 i = 0; i < spenders.length; i++) {\n            if (_allowedTokenSpenders[token].remove(spenders[i])) {\n                emit TokenSpenderAdded(token, spenders[i]);\n            }\n        }\n        if (_allowedTokenSpenders[token].length() == 0) {\n            if (_tokenSet.remove(token)) {\n                _removeContractFuncs(token, _approveFuncs);\n                emit TokenRemoved(token);\n            }\n        }\n    }\n\n    function getAllTokens() external view returns (address[] memory) {\n        return _tokenSet.values();\n    }\n\n    function getTokenSpenders(address token) external view returns (address[] memory) {\n        return _allowedTokenSpenders[token].values();\n    }\n\n}\n"
    },
    "src/authorizations/ERC20TransferAuthorization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport {Type} from \"../common/Type.sol\";\nimport {FunctionAuthorization} from \"../common/FunctionAuthorization.sol\";\nimport {Governable} from \"../utils/Governable.sol\";\n\ncontract ERC20TransferAuthorization is FunctionAuthorization {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    string public constant NAME = \"SolvVaultGuardian_ERC20TransferAuthorization\";\n    int256 public constant VERSION = 1;\n\n    string internal constant ERC20_TRANSFER_FUNC = \"transfer(address,uint256)\";\n    bytes4 internal constant TRANSFER_SELECTOR = 0xa9059cbb;\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    event TokenAdded(address indexed token);\n    event TokenRemoved(address indexed token);\n    event TokenReceiverAdded(address indexed token, address indexed receiver);\n\n    address public safeAccount;\n    string[] internal _transferFuncs;\n\n    EnumerableSet.AddressSet internal _tokenSet;\n    mapping(address => EnumerableSet.AddressSet) internal _allowedTokenReceivers;\n\n    struct TokenReceivers {\n        address token;\n        address[] receivers;\n    }\n\n    constructor(address safeMultiSendContract_, address caller_, TokenReceivers[] memory tokenReceivers_)\n        FunctionAuthorization(safeMultiSendContract_, caller_, Governable(caller_).governor())\n    {\n        _transferFuncs = new string[](1);\n        _transferFuncs[0] = ERC20_TRANSFER_FUNC;\n        _addTokenReceivers(tokenReceivers_);\n    }\n\n    function addTokenReceivers(TokenReceivers[] calldata tokenReceiversList_) external virtual onlyGovernor {\n        _addTokenReceivers(tokenReceiversList_);\n    }\n\n    function removeTokenReceivers(TokenReceivers[] calldata tokenReceiversList_) external virtual onlyGovernor {\n        _removeTokenReceivers(tokenReceiversList_);\n    }\n\n    function _addTokenReceivers(TokenReceivers[] memory _tokenReceiversList) internal virtual {\n        for (uint256 i = 0; i < _tokenReceiversList.length; i++) {\n            _addTokenReceivers(_tokenReceiversList[i]);\n        }\n    }\n\n    function _removeTokenReceivers(TokenReceivers[] memory _tokenReceiversList) internal virtual {\n        for (uint256 i = 0; i < _tokenReceiversList.length; i++) {\n            _removeTokenReceivers(_tokenReceiversList[i]);\n        }\n    }\n\n    function _addTokenReceivers(TokenReceivers memory _tokenReceivers) internal virtual {\n        address token = _tokenReceivers.token;\n        address[] memory receivers = _tokenReceivers.receivers;\n        if (_tokenSet.add(token)) {\n            _addContractFuncs(token, _transferFuncs);\n            emit TokenAdded(token);\n        }\n        for (uint256 i = 0; i < receivers.length; i++) {\n            if (_allowedTokenReceivers[token].add(receivers[i])) {\n                emit TokenReceiverAdded(token, receivers[i]);\n            }\n        }\n    }\n\n    function _removeTokenReceivers(TokenReceivers memory _tokenReceivers) internal virtual {\n        address token = _tokenReceivers.token;\n        address[] memory receivers = _tokenReceivers.receivers;\n        for (uint256 i = 0; i < receivers.length; i++) {\n            if (_allowedTokenReceivers[token].remove(receivers[i])) {\n                emit TokenReceiverAdded(token, receivers[i]);\n            }\n        }\n        if (_allowedTokenReceivers[token].length() == 0) {\n            if (_tokenSet.remove(token)) {\n                _removeContractFuncs(token, _transferFuncs);\n                emit TokenRemoved(token);\n            }\n        }\n    }\n\n    function getAllTokens() external view returns (address[] memory) {\n        return _tokenSet.values();\n    }\n\n    function getTokenReceivers(address token) external view returns (address[] memory) {\n        return _allowedTokenReceivers[token].values();\n    }\n\n    function _checkSingleTx(address, /* from_ */ address to_, bytes calldata data_, uint256 value_)\n        internal\n        virtual\n        override\n        returns (Type.CheckResult memory result)\n    {\n        if (data_.length == 68 && bytes4(data_[0:4]) == TRANSFER_SELECTOR && value_ == 0) {\n            (address recipient, /* uint256 amount */ ) = abi.decode(data_[4:], (address, uint256));\n            if (!_allowedTokenReceivers[to_].contains(recipient)) {\n                result.success = false;\n                result.message = \"ERC20TransferAuthorization: ERC20 receiver not allowed\";\n            } else {\n                result.success = true;\n            }\n        } else {\n            result.success = false;\n            result.message = \"ERC20TransferAuthorization: not ERC20 Transfer\";\n            return result;\n        }\n    }\n}\n"
    },
    "src/authorizations/gmxv1/GMXV1Authorization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {FunctionAuthorization} from \"../../common/FunctionAuthorization.sol\";\nimport {GMXV1AuthorizationACL} from \"./GMXV1AuthorizationACL.sol\";\nimport {Governable} from \"../../utils/Governable.sol\";\n\ncontract GMXV1Authorization is FunctionAuthorization {\n\n    string public constant NAME = \"SolvVaultGuardian_GMXV1Authorization\";\n    uint256 public constant VERSION = 1;\n\n    address public constant GMX_REWAED_ROUTER_V2 = 0xB95DB5B167D75e6d04227CfFFA61069348d271F5;\n    address public constant GMX_REWAED_ROUTER = 0xA906F338CB21815cBc4Bc87ace9e68c87eF8d8F1;\n\n    string public constant ERC20_APPROVE_FUNC = \"approve(address,uint256)\";\n    string public constant ERC20_TRANSFER_FUNC = \"transfer(address,uint256)\";\n\n    constructor(address safeAccount_, address safeMultiSendContract_, address caller_)\n        FunctionAuthorization(safeMultiSendContract_, caller_, Governable(caller_).governor())\n    {\n        string[] memory glpRewardRouterV2Funcs = new string[](3);\n        glpRewardRouterV2Funcs[0] = \"handleRewards(bool,bool,bool,bool,bool,bool,bool)\";\n        glpRewardRouterV2Funcs[1] = \"claim()\";\n        glpRewardRouterV2Funcs[2] = \"compound()\";\n\n        _addContractFuncs(GMX_REWAED_ROUTER, glpRewardRouterV2Funcs);\n\n        string[] memory glpRewardRouterFuncs = new string[](4);\n        glpRewardRouterFuncs[0] = \"mintAndStakeGlp(address,uint256,uint256,uint256)\";\n        glpRewardRouterFuncs[1] = \"unstakeAndRedeemGlp(address,uint256,uint256,address)\";\n        glpRewardRouterFuncs[2] = \"mintAndStakeGlpETH(uint256,uint256)\";\n        glpRewardRouterFuncs[3] = \"unstakeAndRedeemGlpETH(uint256,uint256,address)\";\n\n        _addContractFuncs(GMX_REWAED_ROUTER_V2, glpRewardRouterFuncs);\n\n        string[] memory tokensFuncs = new string[](2);\n        tokensFuncs[0] = ERC20_APPROVE_FUNC;\n        tokensFuncs[1] = ERC20_TRANSFER_FUNC;\n\n        address[] memory tokens = new address[](10);\n        tokens[0] = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1; //WETH\n        tokens[1] = 0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f; //WBTC\n        tokens[2] = 0xf97f4df75117a78c1A5a0DBb814Af92458539FB4; //LINK\n        tokens[3] = 0xFa7F8980b0f1E64A2062791cc3b0871572f1F7f0; //UNI\n        tokens[4] = 0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8; //USDC\n        tokens[5] = 0xaf88d065e77c8cC2239327C5EDb3A432268e5831; //USDC\n        tokens[6] = 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1; //DAI\n        tokens[7] = 0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9; //USDT\n        tokens[8] = 0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F; //FRAX\n        tokens[9] = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; //ETH\n        for (uint256 i = 0; i < tokens.length; i++) {\n            _addContractFuncs(tokens[i], tokensFuncs);\n        }\n\n        address acl = address(new GMXV1AuthorizationACL(address(this), safeAccount_, tokens));\n        _setContractACL(GMX_REWAED_ROUTER_V2, acl);\n    }\n}\n"
    },
    "src/authorizations/gmxv1/GMXV1AuthorizationACL.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport {BaseACL} from \"../../common/BaseACL.sol\";\n\ncontract GMXV1AuthorizationACL is BaseACL {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    string public constant NAME = \"SolvVaultGuard_GMXV1AuthorizationACL\";\n    uint256 public constant VERSION = 1;\n\n    address public constant GLP_REWAED_ROUTER = 0xB95DB5B167D75e6d04227CfFFA61069348d271F5;\n    address public constant NATIVE_ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    EnumerableSet.AddressSet internal _allowTokens;\n\n    constructor(address caller_, address safeAccount_, address[] memory tokens_) BaseACL(caller_) {\n        for (uint256 i = 0; i < tokens_.length; i++) {\n            _allowTokens.add(tokens_[i]);\n        }\n        safeAccount = safeAccount_;\n    }\n\n    function mintAndStakeGlp(address _token, uint256, /*_amount*/ uint256, /*_minUsdg*/ uint256 /*_minGlp*/ )\n        external\n        view\n    {\n        require(_allowTokens.contains(_token), \"GMXV1ACL: token not allowed\");\n    }\n\n    function unstakeAndRedeemGlp(address _tokenOut, uint256, /*_glpAmount*/ uint256, /*_minOut*/ address _receiver)\n        external\n        view\n    {\n        require(_allowTokens.contains(_tokenOut), \"GMXV1ACL: token not allowed\");\n        require(_receiver == safeAccount, \"GMXV1ACL: receiver not safeAccount\");\n    }\n\n    function mintAndStakeGlpETH(uint256, /*_minUsdg*/ uint256 /*_minGlp*/ ) external view {\n        require(_allowTokens.contains(NATIVE_ETH), \"GMXV1ACL: token not allowed\");\n    }\n\n    function unstakeAndRedeemGlpETH(uint256, /*_glpAmount*/ uint256, /*_minOut*/ address payable _receiver)\n        external\n        view\n    {\n        require(_allowTokens.contains(NATIVE_ETH), \"GMXV1ACL: token not allowed\");\n        require(_receiver == safeAccount, \"GMXV1ACL: receiver not safeAccount\");\n    }\n}\n"
    },
    "src/authorizations/gmxv2/GMXV2Authorization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {FunctionAuthorization} from \"../../common/FunctionAuthorization.sol\";\nimport {GMXV2AuthorizationACL} from \"./GMXV2AuthorizationACL.sol\";\nimport {Governable} from \"../../utils/Governable.sol\";\n\ncontract GMXV2Authorization is FunctionAuthorization {\n\n    string public constant NAME = \"SolvVaultGuard_GMXV2Authorization\";\n    uint256 public constant VERSION = 1;\n\n    string public constant ERC20_APPROVE_FUNC = \"approve(address,uint256)\";\n    string public constant ERC20_TRANSFER_FUNC = \"transfer(address,uint256)\";\n\n    /**\n     * On Arbitrum\n     * gmxExchangeRouter: 0x7C68C7866A64FA2160F78EEaE12217FFbf871fa8\n     * gmxDepositVault: 0xF89e77e8Dc11691C9e8757e84aaFbCD8A67d7A55\n     * gmxWithdrawalVault: 0x0628D46b5D145f183AdB6Ef1f2c97eD1C4701C55\n     */\n    constructor(\n        address safeMultiSendContract_,\n        address caller_,\n        address safeAccount_,\n        address exchangeRouter_,\n        address depositVault_,\n        address withdrawalVault_\n    ) FunctionAuthorization(safeMultiSendContract_, caller_, Governable(caller_).governor()) {\n        string[] memory gmxExchangeRouterFuncs = new string[](1);\n        gmxExchangeRouterFuncs[0] = \"multicall(bytes[])\";\n        _addContractFuncs(exchangeRouter_, gmxExchangeRouterFuncs);\n\n        string[] memory tokensFuncs = new string[](2);\n        tokensFuncs[0] = ERC20_APPROVE_FUNC;\n        tokensFuncs[1] = ERC20_TRANSFER_FUNC;\n\n        address[] memory tokens = new address[](4);\n        tokens[0] = 0xaf88d065e77c8cC2239327C5EDb3A432268e5831; // USDC\n        tokens[1] = 0x47c031236e19d024b42f8AE6780E44A573170703; // GM: BTC-USDC\n        tokens[2] = 0x70d95587d40A2caf56bd97485aB3Eec10Bee6336; // GM: ETH-USDC\n        tokens[3] = 0xC25cEf6061Cf5dE5eb761b50E4743c1F5D7E5407; // GM: ARB-USDC\n        for (uint256 i = 0; i < tokens.length; i++) {\n            _addContractFuncs(tokens[i], tokensFuncs);\n        }\n\n        // add GMXV2AuthorizationACL\n        address[] memory gmTokens = new address[](3);\n        gmTokens[0] = 0x47c031236e19d024b42f8AE6780E44A573170703; // GM: BTC-USDC\n        gmTokens[1] = 0x70d95587d40A2caf56bd97485aB3Eec10Bee6336; // GM: ETH-USDC\n        gmTokens[2] = 0xC25cEf6061Cf5dE5eb761b50E4743c1F5D7E5407; // GM: ARB-USDC\n\n        GMXV2AuthorizationACL.CollateralPair[] memory gmPairs = new GMXV2AuthorizationACL.CollateralPair[](3);\n        gmPairs[0] = GMXV2AuthorizationACL.CollateralPair({\n            longCollateral: 0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f, // WBTC\n            shortCollateral: 0xaf88d065e77c8cC2239327C5EDb3A432268e5831 // USDC\n        });\n        gmPairs[1] = GMXV2AuthorizationACL.CollateralPair({\n            longCollateral: 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1, // WETH\n            shortCollateral: 0xaf88d065e77c8cC2239327C5EDb3A432268e5831 // USDC\n        });\n        gmPairs[2] = GMXV2AuthorizationACL.CollateralPair({\n            longCollateral: 0x912CE59144191C1204E64559FE8253a0e49E6548, // ARB\n            shortCollateral: 0xaf88d065e77c8cC2239327C5EDb3A432268e5831 // USDC\n        });\n        address acl = address(\n            new GMXV2AuthorizationACL(address(this), safeAccount_, exchangeRouter_, \n            depositVault_, withdrawalVault_, gmTokens, gmPairs)\n        );\n        _setContractACL(exchangeRouter_, acl);\n    }\n}\n"
    },
    "src/authorizations/gmxv2/GMXV2AuthorizationACL.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport {BaseACL} from \"../../common/BaseACL.sol\";\n\nstruct CreateDepositParams {\n    address receiver;\n    address callbackContract;\n    address uiFeeReceiver;\n    address market;\n    address initialLongToken;\n    address initialShortToken;\n    address[] longTokenSwapPath;\n    address[] shortTokenSwapPath;\n    uint256 minMarketTokens;\n    bool shouldUnwrapNativeToken;\n    uint256 executionFee;\n    uint256 callbackGasLimit;\n}\n\nstruct CreateWithdrawalParams {\n    address receiver;\n    address callbackContract;\n    address uiFeeReceiver;\n    address market;\n    address[] longTokenSwapPath;\n    address[] shortTokenSwapPath;\n    uint256 minLongTokenAmount;\n    uint256 minShortTokenAmount;\n    bool shouldUnwrapNativeToken;\n    uint256 executionFee;\n    uint256 callbackGasLimit;\n}\n\ncontract GMXV2AuthorizationACL is BaseACL {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    string public constant NAME = \"SolvVaultGuard_GMXV2AuthorizationACL\";\n    uint256 public constant VERSION = 1;\n\n    struct CollateralPair {\n        address longCollateral;\n        address shortCollateral;\n    }\n\n    mapping(address => CollateralPair) public authorizedPools;\n    address public exchangeRouter;\n    address public depositVault;\n    address public withdrawalVault;\n\n    event AddGmxPool(address indexed gmToken, CollateralPair collateralPair);\n\n    constructor(\n        address caller_,\n        address safeAccount_,\n        address exchangeRouter_,\n        address depositVault_,\n        address withdrawalVault_,\n        address[] memory gmTokens_,\n        CollateralPair[] memory collateralPairs_\n    ) BaseACL(caller_) {\n        safeAccount = safeAccount_;\n        exchangeRouter = exchangeRouter_;\n        depositVault = depositVault_;\n        withdrawalVault = withdrawalVault_;\n\n        require(gmTokens_.length == collateralPairs_.length, \"array length not matches\");\n        for (uint256 i = 0; i < gmTokens_.length; i++) {\n            _addGmxPool(gmTokens_[i], collateralPairs_[i]);\n        }\n    }\n\n    function _addGmxPool(address gmToken_, CollateralPair memory collateralPair_) internal {\n        require(\n            gmToken_ != address(0) && collateralPair_.longCollateral != address(0)\n                && collateralPair_.shortCollateral != address(0),\n            \"invalid token addresses\"\n        );\n        authorizedPools[gmToken_] = collateralPair_;\n        emit AddGmxPool(gmToken_, collateralPair_);\n    }\n\n    function isPoolAuthorized(address gmToken_) public view returns (bool) {\n        return authorizedPools[gmToken_].longCollateral != address(0);\n    }\n\n    function multicall(bytes[] calldata data) external view {\n        require(data.length == 2 || data.length == 3, \"invalid data length\");\n        uint256 value = _txn().value;\n        bytes4 operation = bytes4(data[data.length - 1]);\n\n        if (operation == this.createDeposit.selector) {\n            (CreateDepositParams memory depositParams) = abi.decode(data[data.length - 1][4:], (CreateDepositParams));\n            createDeposit(depositParams);\n\n            // for deposit operations, the first call should be `sendWnt` and the receiver should be GmxDepositVault\n            require(bytes4(data[0]) == this.sendWnt.selector, \"sendWnt error\");\n            (address wntReceiver, uint256 amount) = abi.decode(data[0][4:], (address, uint256));\n            require(wntReceiver == depositVault, \"invalid wnt receiver\");\n            require(amount == value, \"invalid wnt amount\");\n\n            // for deposit operations with non-ETH tokens, the second call should be `sendTokens`\n            if (data.length == 3) {\n                require(bytes4(data[1]) == this.sendTokens.selector, \"sendTokens error\");\n                (address token, address tokenReceiver,) = abi.decode(data[1][4:], (address, address, uint256));\n                CollateralPair memory collateralPair = authorizedPools[depositParams.market];\n                require(\n                    token == collateralPair.longCollateral || token == collateralPair.shortCollateral,\n                    \"token not authorized\"\n                );\n                require(tokenReceiver == depositVault, \"invalid token receiver\");\n            }\n        } else if (operation == this.createWithdrawal.selector) {\n            (CreateWithdrawalParams memory withdrawalParams) =\n                abi.decode(data[data.length - 1][4:], (CreateWithdrawalParams));\n            createWithdrawal(withdrawalParams);\n\n            // for withdrawal operations, the first call should be `sendWnt` and the receiver should be GmxWithdrawalVault\n            require(bytes4(data[0]) == this.sendWnt.selector, \"sendWnt error\");\n            (address wntReceiver, uint256 amount) = abi.decode(data[0][4:], (address, uint256));\n            require(wntReceiver == withdrawalVault, \"invalid wnt receiver\");\n            require(amount == value, \"invalid wnt amount\");\n\n            // for withdrawal operations, the second call should be `sendTokens` and the receiver should be GmxWithdrawalVault\n            require(bytes4(data[1]) == this.sendTokens.selector, \"sendTokens error\");\n            (address token, address tokenReceiver,) = abi.decode(data[1][4:], (address, address, uint256));\n            require(token == withdrawalParams.market, \"GM token not matches\");\n            require(tokenReceiver == withdrawalVault, \"invalid token receiver\");\n        } else {\n            revert(\"not deposit or withdraw operation\");\n        }\n    }\n\n    function sendWnt(address, /* receiver */ uint256 /* amount */ ) external pure {\n        revert(\"sendWnt not allowed\");\n    }\n\n    function sendTokens(address, /* token */ address, /* receiver */ uint256 /* amount */ ) external pure {\n        revert(\"sendTokens not allowed\");\n    }\n\n    function createDeposit(CreateDepositParams memory depositParams) public view {\n        require(isPoolAuthorized(depositParams.market), \"pool not authorized\");\n        require(depositParams.receiver == safeAccount, \"invalid deposit receiver\");\n        require(depositParams.callbackContract == address(0), \"deposit callback not allowed\");\n    }\n\n    function createWithdrawal(CreateWithdrawalParams memory withdrawalParams) public view {\n        require(isPoolAuthorized(withdrawalParams.market), \"pool not authorized\");\n        require(withdrawalParams.receiver == safeAccount, \"invalid withdrawal receiver\");\n        require(withdrawalParams.callbackContract == address(0), \"withdrawal callback not allowed\");\n    }\n}\n"
    },
    "src/authorizations/lendle/LendleAuthorization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport {FunctionAuthorization} from \"../../common/FunctionAuthorization.sol\";\nimport {LendleAuthorizationACL} from \"./LendleAuthorizationACL.sol\";\nimport {Governable} from \"../../utils/Governable.sol\";\n\ncontract LendleAuthorization is FunctionAuthorization {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    string public constant NAME = \"SolvVaultGuardian_LendleAuthorization\";\n    uint256 public constant VERSION = 1;\n\n    /**\n     * On Mantle\n     * Lendle LendingPool: 0xCFa5aE7c2CE8Fadc6426C1ff872cA45378Fb7cF3\n     */\n    constructor(\n        address safeMultiSendContract_,\n        address caller_,\n        address safeAccount_,\n        address lendingPool_,\n        address[] memory assetWhitelist_\n    ) \n        FunctionAuthorization(safeMultiSendContract_, caller_, Governable(caller_).governor()) \n    {\n        string[] memory lendingPoolFuncs = new string[](5);\n        lendingPoolFuncs[0] = \"deposit(address,uint256,address,uint16)\";\n        lendingPoolFuncs[1] = \"withdraw(address,uint256,address)\";\n        lendingPoolFuncs[2] = \"borrow(address,uint256,uint256,uint16,address)\";\n        lendingPoolFuncs[3] = \"withdraw(address,uint256,uint256,address)\";\n        lendingPoolFuncs[4] = \"swapBorrowRateMode(address,uint256)\";\n        _addContractFuncs(lendingPool_, lendingPoolFuncs);\n\n        address acl = address(new LendleAuthorizationACL(address(this), safeAccount_, lendingPool_, assetWhitelist_));\n        _setContractACL(lendingPool_, acl);\n    }\n}\n"
    },
    "src/authorizations/lendle/LendleAuthorizationACL.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport {BaseACL} from \"../../common/BaseACL.sol\";\n\ncontract LendleAuthorizationACL is BaseACL {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    string public constant NAME = \"SolvVaultGuardian_AgniAuthorizationACL\";\n    uint256 public constant VERSION = 1;\n\n    address public lendingPool;\n\n    EnumerableSet.AddressSet internal _tokenWhitelist;\n\n    event AddTokenWhitelist(address indexed token);\n\n    constructor(\n        address caller_,\n        address safeAccount_,\n        address lendingPool_,\n        address[] memory tokenWhitelist_\n    ) BaseACL(caller_) {\n        safeAccount = safeAccount_;\n        lendingPool = lendingPool_;\n        for (uint256 i = 0; i < tokenWhitelist_.length; i++) {\n            _addTokenWhitelist(tokenWhitelist_[i]);\n        }\n    }\n\n    function _addTokenWhitelist(address token) internal {\n        require(token != address(0), \"LendleACL: token cannot be the zero address\");\n        if (_tokenWhitelist.add(token)) {\n            emit AddTokenWhitelist(token);\n        }\n    }\n\n    function checkToken(address token) public view virtual returns (bool) {\n        return _tokenWhitelist.contains(token);\n    }\n\n    function deposit(address asset, uint256 /* amount */, address onBehalfOf, uint16 /* referralCode */) external view virtual {\n        require(onBehalfOf == safeAccount, \"LendleACL: onBehalfOf not allowed\");\n        require(checkToken(asset), \"LendleACL: asset not allowed\");\n    }\n\n    function withdraw(address asset, uint256 /* amount */, address to) external view virtual {\n        require(to == safeAccount, \"LendleACL: recipient not allowed\");\n        require(checkToken(asset), \"LendleACL: asset not allowed\");\n    }\n\n    function borrow(address asset, uint256 /* amount */, uint256 /* interestRateMode */, uint16 /* referralCode */, address onBehalfOf) external view virtual {\n        require(onBehalfOf == safeAccount, \"LendleACL: onBehalfOf not allowed\");\n        require(checkToken(asset), \"LendleACL: asset not allowed\");\n    }\n\n    function repay(address asset, uint256 /* amount */, uint256 /* rateMode */, address onBehalfOf) external view virtual {\n        require(onBehalfOf == safeAccount, \"LendleACL: onBehalfOf not allowed\");\n        require(checkToken(asset), \"LendleACL: asset not allowed\");\n    }\n\n    function swapBorrowRateMode(address asset, uint256 /* rateMode */) external view virtual {\n        require(checkToken(asset), \"LendleACL: asset not allowed\");\n    }\n\n}\n"
    },
    "src/authorizations/SolvOpenEndFundAuthorization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {FunctionAuthorization} from \"../common/FunctionAuthorization.sol\";\nimport {SolvOpenEndFundAuthorizationACL} from \"./SolvOpenEndFundAuthorizationACL.sol\";\nimport {Governable} from \"../utils/Governable.sol\";\n\ncontract SolvOpenEndFundAuthorization is FunctionAuthorization {\n    string public constant NAME = \"SolvVaultGuardian_SolvOpenEndFundAuthorization\";\n    int256 public constant VERSION = 1;\n\n    string public constant SHARE_FUNC_REPAY = \"repay(uint256,address,uint256)\";\n    string public constant REDEMPTION_FUNC_REPAY = \"repay(uint256,address,uint256)\";\n\n    constructor(\n        address safeMultiSendContract_,\n        address caller_,\n        address openEndFundShare_,\n        address openEndFundRedemption_,\n        bytes32[] memory repayablePoolIds_\n    ) FunctionAuthorization(safeMultiSendContract_, caller_, Governable(caller_).governor()) {\n        string[] memory openEndFundShareFuncs = new string[](1);\n        openEndFundShareFuncs[0] = SHARE_FUNC_REPAY;\n        _addContractFuncs(openEndFundShare_, openEndFundShareFuncs);\n\n        string[] memory openEndFundRedemptionFuncs = new string[](1);\n        openEndFundRedemptionFuncs[0] = REDEMPTION_FUNC_REPAY;\n        _addContractFuncs(openEndFundRedemption_, openEndFundRedemptionFuncs);\n\n        address acl = address(new SolvOpenEndFundAuthorizationACL(address(this), openEndFundRedemption_, repayablePoolIds_));\n        _setContractACL(openEndFundShare_, acl);\n        _setContractACL(openEndFundRedemption_, acl);\n    }\n}\n"
    },
    "src/authorizations/SolvOpenEndFundAuthorizationACL.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport {BaseACL} from \"../common/BaseACL.sol\";\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ninterface ISFTDelegate {\n    function valueDecimals() external view returns (uint8);\n    function concrete() external view returns (address);\n    function contractType() external view returns (string memory);\n}\n\ninterface IOpenFundShareConcrete {\n    function slotBaseInfo(uint256 slot) external view returns (\n        address issuer, address currency, uint64 valueDate, uint64 maturity, \n        uint64 createTime, bool transferable, bool isValid\n    );\n    function slotExtInfo(uint256 slot) external view returns (\n        address supervisor, uint256 issueQuota, uint8 interestType, \n        int32 interestRate, bool isInterestRateSet, string memory externalURI\n    );\n    function slotTotalValue(uint256 slot) external view returns (uint256);\n    function slotCurrencyBalance(uint256 slot) external view returns (uint256);\n}\n\ninterface IOpenFundRedemptionConcrete {\n    function getRedeemInfo(uint256 slot) external view returns (bytes32 poolId, address currency, uint256 createTime, uint256 nav);\n    function slotTotalValue(uint256 slot) external view returns (uint256);\n    function slotCurrencyBalance(uint256 slot) external view returns (uint256);\n}\n\ncontract SolvOpenEndFundAuthorizationACL is BaseACL {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    string public constant NAME = \"SolvVaultGuard_SolvOpenFundAuthorizationACL\";\n    uint256 public constant VERSION = 1;\n\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 internal FULL_PERCENTAGE = 1e4;\n    uint256 internal REPAY_RATE_SCALAR = 1e8;\n\n    address public solvV3OpenEndFundRedemption;\n\n    EnumerableSet.Bytes32Set internal _repayablePoolIds;\n\n    constructor(address caller_, address solvV3OpenEndFundRedemption_, bytes32[] memory repayablePoolIds_)\n        BaseACL(caller_)\n    {\n        solvV3OpenEndFundRedemption = solvV3OpenEndFundRedemption_;\n        for (uint256 i = 0; i < repayablePoolIds_.length; i++) {\n            _repayablePoolIds.add(repayablePoolIds_[i]);\n        }\n    }\n\n    function getAllRepayablePoolIds() public view returns (bytes32[] memory) {\n        return _repayablePoolIds.values();\n    }\n\n    function repay(uint256 slot_, address currency_, uint256 repayCurrencyAmount_) external view {\n        uint256 transactionValue = _txn().value;\n        if (currency_ == ETH) {\n            require(transactionValue == repayCurrencyAmount_, \"SolvOpenEndFundAuthorizationACL: transaction value too much\");\n        } else {\n            require(transactionValue == 0, \"SolvOpenEndFundAuthorizationACL: transaction value not allowed\");\n        }\n\n        _checkRepayment(slot_, repayCurrencyAmount_);\n    }\n\n    function repayWithBalance(uint256 slot_, address, /* currency_ */ uint256 repayCurrencyAmount_) external view {\n        require(_txn().value == 0, \"SolvOpenEndFundAuthorizationACL: transaction value not allowed\");\n        _checkRepayment(slot_, repayCurrencyAmount_);\n    }\n\n    function _checkRepayment(uint256 slot, uint256 repayCurrencyAmount) internal view {\n        string memory contractType = ISFTDelegate(solvV3OpenEndFundRedemption).contractType();\n        address concrete = ISFTDelegate(solvV3OpenEndFundRedemption).concrete();\n\n        if (keccak256(abi.encodePacked(contractType)) == keccak256(abi.encodePacked(\"Open Fund Shares\"))) {\n            require(repayCurrencyAmount <= _shareUnpaidAmount(concrete, slot), \"SolvOpenEndFundAuthorizationACL: share over paid\");\n\n        } else if (keccak256(abi.encodePacked(contractType)) == keccak256(abi.encodePacked(\"Open Fund Redemptions\"))) {\n            require(repayCurrencyAmount <= _redemptionUnpaidAmount(concrete, slot), \"SolvOpenEndFundAuthorizationACL: redemption over paid\");\n\n        } else {\n            revert(\"SolvOpenEndFundAuthorizationACL: invalid contract type\");\n        }\n    }\n\n    function _shareUnpaidAmount(address concrete, uint256 slot) internal view virtual returns (uint256) {\n        (, address currency, uint64 valueDate, uint64 maturity,,,) = IOpenFundShareConcrete(concrete).slotBaseInfo(slot);\n        (,,, int32 interestRate, bool isInterestRateSet,) = IOpenFundShareConcrete(concrete).slotExtInfo(slot);\n        require(isInterestRateSet, \"SolvOpenEndFundAuthorizationACL: interest rate not set\");\n\n        uint256 scaledFullPercentage = FULL_PERCENTAGE * REPAY_RATE_SCALAR;\n        uint256 scaledPositiveInterestRate = \n            (interestRate < 0 ? uint256(int256(0 - interestRate)) : uint256(int256(interestRate))) * \n            REPAY_RATE_SCALAR * (maturity - valueDate) / (360 * 24 * 60 * 60);\n        uint256 repayRate = interestRate < 0 ? scaledFullPercentage - scaledPositiveInterestRate : \n            scaledFullPercentage + scaledPositiveInterestRate;\n\n        uint8 currencyDecimals = currency == ETH ? 18 : IERC20(currency).decimals();\n        uint8 shareDecimals = ISFTDelegate(solvV3OpenEndFundRedemption).valueDecimals();\n\n        uint256 slotTotalValue = IOpenFundShareConcrete(concrete).slotTotalValue(slot);\n        uint256 slotCurrencyBalance = IOpenFundShareConcrete(concrete).slotCurrencyBalance(slot);\n        uint256 payableAmount = slotTotalValue * repayRate * (10 ** currencyDecimals) / FULL_PERCENTAGE / REPAY_RATE_SCALAR / (10 ** shareDecimals);\n        return payableAmount - slotCurrencyBalance;\n    }\n\n    function _redemptionUnpaidAmount(address concrete, uint256 slot) internal view virtual returns (uint256) {\n        (bytes32 poolId,,, uint256 redeemNav) = IOpenFundRedemptionConcrete(concrete).getRedeemInfo(slot);\n        require(_repayablePoolIds.contains(poolId), \"SolvOpenEndFundAuthorizationACL: pool not repayable\");\n\n        uint256 slotTotalValue = IOpenFundRedemptionConcrete(concrete).slotTotalValue(slot);\n        uint256 slotCurrencyBalance = IOpenFundRedemptionConcrete(concrete).slotCurrencyBalance(slot);\n        uint8 decimals = ISFTDelegate(solvV3OpenEndFundRedemption).valueDecimals();\n        return slotTotalValue * redeemNav / (10 ** decimals) - slotCurrencyBalance;\n    }\n\n}\n"
    },
    "src/common/BaseACL.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Type} from \"./Type.sol\";\n\nabstract contract BaseACL {\n    address public caller;\n    address public safeAccount;\n    address public solvGuard;\n\n    constructor(address caller_) {\n        caller = caller_;\n    }\n\n    modifier onlyCaller() virtual {\n        require(msg.sender == caller, \"onlyCaller\");\n        _;\n    }\n\n    function preCheck(address from_, address to_, bytes calldata data_, uint256 value_)\n        external\n        virtual\n        onlyCaller\n        returns (Type.CheckResult memory result_)\n    {\n        result_ = _preCheck(from_, to_, data_, value_);\n    }\n\n    function _preCheck(address from_, address to_, bytes calldata data_, uint256 value_)\n        internal\n        virtual\n        returns (Type.CheckResult memory result_)\n    {\n        (bool success, bytes memory revertData) =\n            address(this).staticcall(_packTxn(Type.TxData(from_, to_, value_, data_)));\n        result_ = _parseReturnData(success, revertData);\n    }\n\n    function _parseReturnData(bool success, bytes memory revertData)\n        internal\n        pure\n        returns (Type.CheckResult memory result_)\n    {\n        if (success) {\n            // ACL checking functions should not return any bytes which differs from normal view functions.\n            require(revertData.length == 0, \"ACL Function return non empty\");\n            result_.success = true;\n        } else {\n            if (revertData.length < 68) {\n                // 8(bool) + 32(length)\n                result_.message = string(revertData);\n            } else {\n                assembly {\n                    // Slice the sighash.\n                    revertData := add(revertData, 0x04)\n                }\n                result_.message = abi.decode(revertData, (string));\n            }\n        }\n    }\n\n    function _packTxn(Type.TxData memory txData_) internal pure virtual returns (bytes memory) {\n        bytes memory txnData = abi.encode(txData_);\n        bytes memory callDataSize = abi.encode(txData_.data.length);\n        return abi.encodePacked(txData_.data, txnData, callDataSize);\n    }\n\n    function _unpackTxn() internal view virtual returns (Type.TxData memory txData_) {\n        uint256 end = msg.data.length;\n        uint256 callDataSize = abi.decode(msg.data[end - 32:end], (uint256));\n        txData_ = abi.decode(msg.data[callDataSize:], (Type.TxData));\n    }\n\n    function _txn() internal view virtual returns (Type.TxData memory) {\n        return _unpackTxn();\n    }\n\n    function _checkValueZero() internal view virtual {\n        require(_txn().value == 0, \"Value not zero\");\n    }\n}\n"
    },
    "src/common/BaseAuthorization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Type} from \"./Type.sol\";\nimport {Governable} from \"../utils/Governable.sol\";\n\nabstract contract BaseAuthorization is Governable {\n    address public caller;\n\n    modifier onlyCaller() {\n        if (msg.sender != caller) {\n            revert(\"BaseAuthorization: onlySelf\");\n        }\n        _;\n    }\n\n    constructor(address caller_, address governor_) Governable(governor_) {\n        caller = caller_;\n    }\n\n    fallback() external {\n        // We don't revert on fallback to avoid issues in case of a Safe upgrade\n        // E.g. The expected check method might change and then the Safe would be locked.\n    }\n\n    function authorizationCheckTransaction(Type.TxData calldata txData_)\n        external\n        virtual\n        onlyCaller\n        returns (Type.CheckResult memory)\n    {\n        return _authorizationCheckTransaction(txData_);\n    }\n\n    function _authorizationCheckTransaction(Type.TxData calldata txData_)\n        internal\n        virtual\n        returns (Type.CheckResult memory);\n}\n"
    },
    "src/common/FunctionAuthorization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport {Type} from \"../common/Type.sol\";\nimport {BaseAuthorization} from \"../common/BaseAuthorization.sol\";\nimport {BaseACL} from \"../common/BaseACL.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\n\nabstract contract FunctionAuthorization is BaseAuthorization, Multicall {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    string public constant SAFE_MULITSEND_FUNC_MULTI_SEND = \"multiSend(bytes)\";\n\n    event AddContractFunc(address indexed contract_, string func_, address indexed sender_);\n    event AddContractFuncSig(address indexed contract_, bytes4 indexed funcSig_, address indexed sender_);\n    event RemoveContractFunc(address indexed contract_, string func_, address indexed sender_);\n    event RemoveContractFuncSig(address indexed contract_, bytes4 indexed funcSig_, address indexed sender_);\n    event SetContractACL(address indexed contract_, address indexed acl_, address indexed sender_);\n\n    address public immutable safeMultiSendContract;\n    EnumerableSet.AddressSet internal _contracts;\n    mapping(address => EnumerableSet.Bytes32Set) internal _allowedContractToFunctions;\n    //contract => acl\n    mapping(address => address) internal _contractACL;\n\n    constructor(address safeMultiSendContract_, address caller_, address governor_)\n        BaseAuthorization(caller_, governor_)\n    {\n        safeMultiSendContract = safeMultiSendContract_;\n    }\n\n    function addContractFuncs(address contract_, address acl_, string[] memory funcList_)\n        external\n        virtual\n        onlyGovernor\n    {\n        _addContractFuncs(contract_, funcList_);\n        if (acl_ != address(0)) {\n            _setContractACL(contract_, acl_);\n        }\n    }\n\n    function removeContractFuncs(address contract_, string[] calldata funcList_) external virtual onlyGovernor {\n        _removeContractFuncs(contract_, funcList_);\n    }\n\n    function addContractFuncsSig(address contract_, address acl_, bytes4[] calldata funcSigList_)\n        external\n        virtual\n        onlyGovernor\n    {\n        _addContractFuncsSig(contract_, funcSigList_);\n        if (acl_ != address(0)) {\n            _setContractACL(contract_, acl_);\n        }\n    }\n\n    function removeContractFuncsSig(address contract_, bytes4[] calldata funcSigList_) external virtual onlyGovernor {\n        _removeContractFuncsSig(contract_, funcSigList_);\n    }\n\n    function setContractACL(address contract_, address acl_) external virtual onlyGovernor {\n        _setContractACL(contract_, acl_);\n    }\n\n    function getAllContracts() public view virtual returns (address[] memory) {\n        return _contracts.values();\n    }\n\n    function getFunctionsByContract(address contract_) public view virtual returns (bytes32[] memory) {\n        return _allowedContractToFunctions[contract_].values();\n    }\n\n    function getACLByContract(address contract_) external view virtual returns (address) {\n        return _contractACL[contract_];\n    }\n\n    function _addContractFuncs(address contract_, string[] memory funcList_) internal virtual {\n        require(funcList_.length > 0, \"FunctionAuthorization: empty funcList\");\n\n        for (uint256 index = 0; index < funcList_.length; index++) {\n            bytes4 funcSelector = bytes4(keccak256(bytes(funcList_[index])));\n            bytes32 funcSelector32 = bytes32(funcSelector);\n            if (_allowedContractToFunctions[contract_].add(funcSelector32)) {\n                emit AddContractFunc(contract_, funcList_[index], msg.sender);\n                emit AddContractFuncSig(contract_, funcSelector, msg.sender);\n            }\n        }\n\n        _contracts.add(contract_);\n    }\n\n    function _addContractFuncsSig(address contract_, bytes4[] memory funcSigList_) internal virtual {\n        require(funcSigList_.length > 0, \"FunctionAuthorization: empty funcList\");\n\n        for (uint256 index = 0; index < funcSigList_.length; index++) {\n            bytes32 funcSelector32 = bytes32(funcSigList_[index]);\n            if (_allowedContractToFunctions[contract_].add(funcSelector32)) {\n                emit AddContractFuncSig(contract_, funcSigList_[index], msg.sender);\n            }\n        }\n\n        _contracts.add(contract_);\n    }\n\n    function _removeContractFuncs(address contract_, string[] memory funcList_) internal virtual {\n        require(funcList_.length > 0, \"FunctionAuthorization: empty funcList\");\n\n        for (uint256 index = 0; index < funcList_.length; index++) {\n            bytes4 funcSelector = bytes4(keccak256(bytes(funcList_[index])));\n            bytes32 funcSelector32 = bytes32(funcSelector);\n            if (_allowedContractToFunctions[contract_].remove(funcSelector32)) {\n                emit RemoveContractFunc(contract_, funcList_[index], msg.sender);\n                emit RemoveContractFuncSig(contract_, funcSelector, msg.sender);\n            }\n        }\n\n        if (_allowedContractToFunctions[contract_].length() == 0) {\n            delete _contractACL[contract_];\n            _contracts.remove(contract_);\n        }\n    }\n\n    function _removeContractFuncsSig(address contract_, bytes4[] calldata funcSigList_) internal virtual {\n        require(funcSigList_.length > 0, \"FunctionAuthorization: empty funcList\");\n\n        for (uint256 index = 0; index < funcSigList_.length; index++) {\n            bytes32 funcSelector32 = bytes32(funcSigList_[index]);\n            if (_allowedContractToFunctions[contract_].remove(funcSelector32)) {\n                emit RemoveContractFuncSig(contract_, funcSigList_[index], msg.sender);\n            }\n        }\n\n        if (_allowedContractToFunctions[contract_].length() == 0) {\n            delete _contractACL[contract_];\n            _contracts.remove(contract_);\n        }\n    }\n\n    function _setContractACL(address contract_, address acl_) internal virtual {\n        _contractACL[contract_] = acl_;\n        emit SetContractACL(contract_, acl_, msg.sender);\n    }\n\n    function _authorizationCheckTransaction(Type.TxData calldata txData_)\n        internal\n        virtual\n        override\n        returns (Type.CheckResult memory result)\n    {\n        return _authorizationCheckTransactionWithRecursion(txData_.from, txData_.to, txData_.data, txData_.value);\n    }\n\n    function _authorizationCheckTransactionWithRecursion(\n        address from_,\n        address to_,\n        bytes calldata data_,\n        uint256 value_\n    ) internal virtual returns (Type.CheckResult memory result_) {\n        if (data_.length == 0) {\n            return _checkNativeTransfer(to_, value_);\n        }\n\n        if (data_.length < 4) {\n            result_.success = false;\n            result_.message = \"FunctionAuthorization: invalid txData\";\n            return result_;\n        }\n\n        bytes4 selector = _getSelector(data_);\n\n        if (to_ == safeMultiSendContract && selector == bytes4(keccak256(bytes(SAFE_MULITSEND_FUNC_MULTI_SEND)))) {\n            result_ = _checkMultiSend(from_, to_, data_, value_);\n        } else {\n            result_ = _checkSingleTx(from_, to_, data_, value_);\n        }\n    }\n\n    function _checkMultiSend(address from_, address, /* to_ */ bytes calldata transactions_, uint256 /* value_ */ )\n        internal\n        virtual\n        returns (Type.CheckResult memory result_)\n    {\n        uint256 multiSendDataLength = uint256(bytes32(transactions_[4 + 32:4 + 32 + 32]));\n        bytes calldata multiSendData = transactions_[4 + 32 + 32:4 + 32 + 32 + multiSendDataLength];\n        uint256 startIndex = 0;\n        while (startIndex < multiSendData.length) {\n            (address to, uint256 value, bytes calldata data, uint256 endIndex) =\n                _unpackMultiSend(multiSendData, startIndex);\n            if (to != address(0)) {\n                result_ = _authorizationCheckTransactionWithRecursion(from_, to, data, value);\n                if (!result_.success) {\n                    return result_;\n                }\n            }\n\n            startIndex = endIndex;\n        }\n\n        result_.success = true;\n    }\n\n    function _unpackMultiSend(bytes calldata transactions_, uint256 startIndex_)\n        internal\n        pure\n        virtual\n        returns (address to_, uint256 value_, bytes calldata data_, uint256 endIndex_)\n    {\n        uint256 offset = 0;\n        uint256 length = 1;\n        offset += length;\n\n        //address 20 bytes\n        length = 20;\n        to_ = address(bytes20(transactions_[startIndex_ + offset:startIndex_ + offset + length]));\n        offset += length;\n\n        //value 32 bytes\n        length = 32;\n        value_ = uint256(bytes32(transactions_[startIndex_ + offset:startIndex_ + offset + length]));\n        offset += length;\n\n        //datalength 32 bytes\n        length = 32;\n        uint256 dataLength = uint256(bytes32(transactions_[startIndex_ + offset:startIndex_ + offset + length]));\n        offset += length;\n\n        //data\n        data_ = transactions_[startIndex_ + offset:startIndex_ + offset + dataLength];\n\n        endIndex_ = startIndex_ + offset + dataLength;\n    }\n\n    function _checkSingleTx(address from_, address to_, bytes calldata data_, uint256 value_)\n        internal\n        virtual\n        returns (Type.CheckResult memory result_)\n    {\n        bytes4 selector = _getSelector(data_);\n        if (_isAllowedSelector(to_, selector)) {\n            result_.success = true;\n            //if allowed, check acl\n            if (_contractACL[to_] != address(0)) {\n                try BaseACL(_contractACL[to_]).preCheck(from_, to_, data_, value_) returns (\n                    Type.CheckResult memory result\n                ) {\n                    return result;\n                } catch Error(string memory reason) {\n                    result_.success = false;\n                    result_.message = reason;\n                } catch (bytes memory reason) {\n                    result_.success = false;\n                    result_.message = string(reason);\n                }\n            }\n        } else {\n            result_.success = false;\n            result_.message = \"FunctionAuthorization: not allowed function\";\n        }\n    }\n\n    function _isAllowedSelector(address target_, bytes4 selector_) internal view virtual returns (bool) {\n        return _allowedContractToFunctions[target_].contains(selector_);\n    }\n\n    function _getSelector(bytes calldata data_) internal pure virtual returns (bytes4 selector_) {\n        assembly {\n            selector_ := calldataload(data_.offset)\n        }\n    }\n\n    // to allow native token transferring, must override this function\n    function _checkNativeTransfer(address, /* to */ uint256 /* value_ */ )\n        internal\n        view\n        virtual\n        returns (Type.CheckResult memory result_)\n    {\n        result_.success = false;\n        result_.message = \"FunctionAuthorization: native token transfer not allowed\";\n    }\n}\n"
    },
    "src/common/SolvVaultGuardianBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport {Type} from \"./Type.sol\";\nimport {BaseAuthorization} from \"./BaseAuthorization.sol\";\nimport {FunctionAuthorization} from \"./FunctionAuthorization.sol\";\n\ncontract SolvVaultGuardianBase is FunctionAuthorization {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct Authorization {\n        string name;\n        address executor;\n        bool enabled;\n    }\n\n    event AllowSetGuard(bool isSetGuardAllowed_);\n    event AddAuthorization(string indexed name, address indexed executor_, bool enabled_);\n    event RemoveAuthorization(string indexed name, address indexed executor_, bool enabled_);\n    event SetAuthorization(string indexed name, address indexed executor_, bool enabled_);\n    event SetNativeTokenTransferAllowed(bool isNativeTokenTransferAllowed_);\n    event AddNativeTokenReceiver(address indexed receiver_);\n    event RemoveNativeTokenReceiver(address indexed receiver_);\n\n    Authorization[] public authorizations;\n\n    address public immutable safeAccount;\n    bool public allowSetGuard;\n    bool public allowNativeTokenTransfer;\n    mapping(address => bool) public nativeTokenReceiver;\n\n    constructor(address safeAccount_, address safeMultiSend_, address governor_, bool allowSetGuard_)\n        FunctionAuthorization(safeMultiSend_, address(this), governor_)\n    {\n        safeAccount = safeAccount_;\n        _setGuardAllowed(allowSetGuard_);\n        _setNativeTokenTransferAllowed(false);\n\n        Authorization memory self =\n            Authorization({name: \"SolvVaultGuardian_GeneralAuthorization\", executor: address(this), enabled: true});\n        authorizations.push(self);\n    }\n\n    function setGuardAllowed(bool allowed_) external virtual onlyGovernor {\n        _setGuardAllowed(allowed_);\n    }\n\n    function _setGuardAllowed(bool allowed_) internal virtual {\n        allowSetGuard = allowed_;\n        emit AllowSetGuard(allowed_);\n    }\n\n    function setNativeTokenTransferAllowed(bool allowed_) external virtual onlyGovernor {\n        _setNativeTokenTransferAllowed(allowed_);\n    }\n\n    function _setNativeTokenTransferAllowed(bool allowed_) internal virtual {\n        allowNativeTokenTransfer = allowed_;\n        emit SetNativeTokenTransferAllowed(allowed_);\n    }\n\n    function addNativeTokenReceiver(address[] calldata receivers_) external virtual onlyGovernor {\n        for (uint256 i = 0; i < receivers_.length; i++) {\n            nativeTokenReceiver[receivers_[i]] = true;\n            emit AddNativeTokenReceiver(receivers_[i]);\n        }\n    }\n\n    function removeNativeTokenReceiver(address[] calldata receivers_) external virtual onlyGovernor {\n        for (uint256 i = 0; i < receivers_.length; i++) {\n            nativeTokenReceiver[receivers_[i]] = false;\n            emit RemoveNativeTokenReceiver(receivers_[i]);\n        }\n    }\n\n    function addAuthorizations(Authorization[] calldata authorizations_) external virtual onlyGovernor {\n        for (uint256 i = 0; i < authorizations_.length; i++) {\n            _addAuthorization(authorizations_[i]);\n        }\n    }\n\n    function removeAuthorizations(address[] calldata executors_) external virtual onlyGovernor {\n        for (uint256 i = 0; i < executors_.length; i++) {\n            _removeAuthorization(executors_[i]);\n        }\n    }\n\n    function setAuthorizationEnabled(address executor_, bool enabled_) external virtual onlyGovernor {\n        _setAuthorizationEnabled(executor_, enabled_);\n    }\n\n    function _addAuthorization(Authorization memory _authorization) internal virtual {\n        for (uint256 i = 0; i < authorizations.length; i++) {\n            require(authorizations[i].executor != _authorization.executor, \"SolvVaultGuardian: guard already exist\");\n        }\n        authorizations.push(_authorization);\n        emit AddAuthorization(_authorization.name, _authorization.executor, _authorization.enabled);\n    }\n\n    function _removeAuthorization(address _executor) internal virtual {\n        for (uint256 i = 0; i < authorizations.length; i++) {\n            if (authorizations[i].executor == _executor) {\n                emit RemoveAuthorization(authorizations[i].name, authorizations[i].executor, authorizations[i].enabled);\n                authorizations[i] = authorizations[authorizations.length - 1];\n                authorizations.pop();\n                break;\n            }\n        }\n    }\n\n    function _setAuthorizationEnabled(address executor_, bool enabled_) internal virtual {\n        for (uint256 i = 0; i < authorizations.length; i++) {\n            if (authorizations[i].executor == executor_) {\n                authorizations[i].enabled = enabled_;\n                emit SetAuthorization(authorizations[i].name, authorizations[i].executor, authorizations[i].enabled);\n                break;\n            }\n        }\n    }\n\n    function _checkSafeTransaction(address to, uint256 value, bytes calldata data, address msgSender)\n        internal\n        virtual\n    {\n        if (to == safeAccount && data.length == 0) {\n            return;\n        }\n        Type.TxData memory txData = Type.TxData({from: msgSender, to: to, value: value, data: data});\n\n        //check safe account setGuard\n        if (to == safeAccount && data.length >= 4 && bytes4(data[0:4]) == bytes4(keccak256(\"setGuard(address)\"))) {\n            require(allowSetGuard, \"SolvVaultGuardian: setGuard disabled\");\n            return;\n        }\n\n        //check authorizations check\n        for (uint256 i = 0; i < authorizations.length; i++) {\n            if (authorizations[i].enabled) {\n                Type.CheckResult memory result =\n                    BaseAuthorization(authorizations[i].executor).authorizationCheckTransaction(txData);\n                //if return true, then passed\n                if (result.success) {\n                    return;\n                }\n            }\n        }\n\n        revert(\"SolvVaultGuardian: checkTransaction failed\");\n    }\n\n    function _checkNativeTransfer(address to_, uint256 /* value_ */ )\n        internal\n        view\n        virtual\n        override\n        returns (Type.CheckResult memory result_)\n    {\n        if (allowNativeTokenTransfer) {\n            if (nativeTokenReceiver[to_]) {\n                result_.success = true;\n                result_.message = \"SolvVaultGuardian: native token transfer allowed\";\n            } else {\n                result_.success = false;\n                result_.message = \"SolvVaultGuardian: native token receiver not allowed\";\n            }\n        } else {\n            result_.success = false;\n            result_.message = \"SolvVaultGuardian: native token transfer not allowed\";\n        }\n    }\n}\n"
    },
    "src/common/Type.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nabstract contract Type {\n\tstruct TxData {\n\t\taddress from; //msg.sender\n\t\taddress to;\n\t\tuint256 value;\n\t\tbytes data; //calldata\n\t}\n\n\tstruct CheckResult {\n\t\tbool success;\n\t\tstring message;\n\t}\n}"
    },
    "src/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity ^0.8.4;\n\nlibrary BytesLib {\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, 'slice_overflow');\n        require(_start + _length >= _start, 'slice_overflow');\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n                case 0 {\n                    // Get a location of some free memory and store it in tempBytes as\n                    // Solidity does for memory variables.\n                    tempBytes := mload(0x40)\n\n                    // The first word of the slice result is potentially a partial\n                    // word read from the original array. To read it, we calculate\n                    // the length of that partial word and start copying that many\n                    // bytes into the array. The first word we copy will start with\n                    // data we don't care about, but the last `lengthmod` bytes will\n                    // land at the beginning of the contents of the new array. When\n                    // we're done copying, we overwrite the full first word with\n                    // the actual length of the slice.\n                    let lengthmod := and(_length, 31)\n\n                    // The multiplication in the next line is necessary\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n                    // the following copy loop was copying the origin's length\n                    // and then ending prematurely not copying everything it should.\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                    let end := add(mc, _length)\n\n                    for {\n                        // The multiplication in the next line has the same exact purpose\n                        // as the one above.\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                    } lt(mc, end) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        mstore(mc, mload(cc))\n                    }\n\n                    mstore(tempBytes, _length)\n\n                    //update free-memory pointer\n                    //allocating the array padded to 32 bytes like the compiler does now\n                    mstore(0x40, and(add(mc, 31), not(31)))\n                }\n                //if we want a zero-length slice let's just return a zero-length array\n                default {\n                    tempBytes := mload(0x40)\n                    //zero out the 32 bytes slice we are about to return\n                    //we need to do it because Solidity does not garbage collect\n                    mstore(tempBytes, 0)\n\n                    mstore(0x40, add(tempBytes, 0x20))\n                }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, 'toAddress_overflow');\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, 'toUint24_overflow');\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n    \n}\n"
    },
    "src/libraries/Path.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./BytesLib.sol\";\n\n/// @title Functions for manipulating path data for multihop swaps\nlibrary Path {\n\n    using BytesLib for bytes;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n    /// @dev The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n    /// @dev The offset of an encoded pool key\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Returns the number of pools in the path\n    /// @param path The encoded swap path\n    /// @return The number of pools in the path\n    function numPools(bytes memory path) internal pure returns (uint256) {\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return tokenB The second token of the given pool\n    /// @return fee The fee level of the pool\n    function decodeFirstPool(bytes memory path)\n        internal\n        pure\n        returns (\n            address tokenA,\n            address tokenB,\n            uint24 fee\n        )\n    {\n        tokenA = path.toAddress(0);\n        fee = path.toUint24(ADDR_SIZE);\n        tokenB = path.toAddress(NEXT_OFFSET);\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(0, POP_OFFSET);\n    }\n\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\n    /// @param path The swap path\n    /// @return The remaining token + fee elements in the path\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\n    }\n    \n}\n"
    },
    "src/SolvVaultGuardianForSafe13.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Guard, Enum} from \"lib/safe-contracts-1.3.0/contracts/base/GuardManager.sol\";\nimport {SolvVaultGuardianBase} from \"./common/SolvVaultGuardianBase.sol\";\n\ncontract SolvVaultGuardianForSafe13 is Guard, SolvVaultGuardianBase {\n    constructor(address safeAccount_, address safeMultiSend_, address governor_, bool allowSetGuard_)\n        SolvVaultGuardianBase(safeAccount_, safeMultiSend_, governor_, allowSetGuard_)\n    {}\n\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation, /*operation*/\n        uint256, /*safeTxGas*/\n        uint256, /*baseGas*/\n        uint256, /*gasPrice*/\n        address, /*gasToken*/\n        address payable, /*refundReceiver*/\n        bytes memory, /*signatures*/\n        address msgSender\n    ) external virtual override {\n        _checkSafeTransaction(to, value, data, msgSender);\n    }\n\n    function checkAfterExecution(bytes32 txHash, bool success) external virtual override {}\n}\n"
    },
    "src/utils/Governable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nabstract contract Governable {\n    event NewGovernor(address indexed previousGovernor, address indexed newGovernor);\n\n    address public governor;\n    bool public governanceAllowed = true;\n\n    constructor(address governor_) {\n        _transferGovernance(governor_);\n    }\n\n    modifier onlyGovernor() {\n        require(governanceAllowed && governor == msg.sender, \"Governable: only governor\");\n        _;\n    }\n\n    function forbidGovernance() external onlyGovernor {\n        governanceAllowed = false;\n    }\n\n    function transferGovernance(address newGovernor_) public onlyGovernor {\n        _transferGovernance(newGovernor_);\n    }\n\n    function _transferGovernance(address newGovernor_) internal {\n        require(newGovernor_ != address(0), \"Governable: new governor is the zero address\");\n        address oldGovernor = governor;\n        governor = newGovernor_;\n        emit NewGovernor(oldGovernor, newGovernor_);\n    }\n}\n"
    },
    "src/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\nabstract contract Multicall {\n\t/**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n\n        for (uint256 i; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                _revertWithParsedMessage(result);\n            }\n\n            results[i] = result;\n        }\n\n        return results;\n    }\n\n\t  function _revertWithParsedMessage(bytes memory result) internal pure {\n        (string memory revertMessage, bool hasRevertMessage) = _getRevertMessage(result);\n\n        if (hasRevertMessage) {\n            revert(revertMessage);\n        } else {\n            _revertWithCustomError(result);\n        }\n    }\n\n    function _revertWithCustomError(bytes memory result) internal pure {\n        // referenced from https://ethereum.stackexchange.com/a/123588\n        uint256 length = result.length;\n        assembly {\n            revert(add(result, 0x20), length)\n        }\n    }\n\n\t // To get the revert reason, referenced from https://ethereum.stackexchange.com/a/83577\n    function _getRevertMessage(bytes memory result) internal pure returns (string memory, bool) {\n        // If the result length is less than 68, then the transaction either panicked or failed silently\n        if (result.length < 68) {\n            return (\"\", false);\n        }\n\n        bytes4 errorSelector = _getErrorSelectorFromData(result);\n\n        // 0x08c379a0 is the selector for Error(string)\n        // referenced from https://blog.soliditylang.org/2021/04/21/custom-errors/\n        if (errorSelector == bytes4(0x08c379a0)) {\n            assembly {\n                result := add(result, 0x04)\n            }\n\n            return (abi.decode(result, (string)), true);\n        }\n\n        // error may be a custom error, return an empty string for this case\n        return (\"\", false);\n    }\n\n\n    function _getErrorSelectorFromData(bytes memory data) internal pure returns (bytes4) {\n        bytes4 errorSelector;\n\n        assembly {\n            errorSelector := mload(add(data, 0x20))\n        }\n\n        return errorSelector;\n    }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x0000000000000031373035383839373030383230"
      }
    }
  }
}